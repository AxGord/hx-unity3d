package unityEngine;
@:native("UnityEngine.NavMeshAgent") extern class NavMeshAgent extends Behaviour {
	var destination:unityEngine.Vector3;
	var stoppingDistance:Float;
	var velocity:unityEngine.Vector3;
	var nextPosition:unityEngine.Vector3;
	var steeringTarget:unityEngine.Vector3;
	var desiredVelocity:unityEngine.Vector3;
	var remainingDistance:Float;
	var baseOffset:Float;
	var isOnOffMeshLink:Bool;
	var currentOffMeshLinkData:unityEngine.OffMeshLinkData;
	var autoTraverseOffMeshLink:Bool;
	var autoRepath:Bool;
	var hasPath:Bool;
	var pathPending:Bool;
	var isPathStale:Bool;
	var pathStatus:unityEngine.NavMeshPathStatus;
	var path:unityEngine.NavMeshPath;
	var walkableMask:Int;
	var speed:Float;
	var angularSpeed:Float;
	var acceleration:Float;
	var updatePosition:Bool;
	var updateRotation:Bool;
	var radius:Float;
	var height:Float;
	var obstacleAvoidanceType:unityEngine.ObstacleAvoidanceType;
	function SetDestination(target:unityEngine.Vector3):Bool;
	function ActivateCurrentOffMeshLink(activated:Bool):Void;
	function CompleteOffMeshLink():Void;
	function Move(offset:unityEngine.Vector3):Void;
	function Stop(stopUpdates:unityEngine.boolean = false):Void;
	function Resume():Void;
	function ResetPath():Void;
	function SetPath(path:unityEngine.NavMeshPath):Bool;
	function FindClosestEdge(out hit:unityEngine.NavMeshHit):Bool;
	function Raycast(targetPosition:unityEngine.Vector3, out hit:unityEngine.NavMeshHit):Bool;
	function CalculatePath(targetPosition:unityEngine.Vector3, path:unityEngine.NavMeshPath):Bool;
	function SamplePathPosition(passableMask:Int, maxDistance:Float, out hit:unityEngine.NavMeshHit):Bool;
	function SetLayerCost(layer:Int, cost:Float):Void;
	function GetLayerCost(layer:Int):Float;
}